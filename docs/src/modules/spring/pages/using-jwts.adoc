= Using JWTs in Spring

include::ROOT:partial$include.adoc[]

https://jwt.io[JSON Web Tokens] (JWTs) offer a way to authenticate and authorize clients to your services, without requiring anything external to your service to verify the tokens. This is ideal in a serverless environment where your services need to be able to run as autonomously as possible.

A JWT consists of a set of claims and a signature that verifies that these claims were issued by an issuer that you trust. These claims may identify a user, or they may indicate that a user has access to a particular resource, or that a user has a particular role, or is a member of a group, etc.

For example, when a user logs in to a system, they may be given a JWT that contains their username as a claim. When the user makes a request on any of your services, they can present that JWT, and those services can verify that the token is valid, and read the username from the JWT to know that this request was made by that user.

When signing JWTs, there are two general approaches, one is to use symmetric keys, the other is to use asymmetric keys. Symmetric keys require the service that issues the token and the service that verifies the token to have the same key. Because they have the same key, they can both issue the same tokens. Symmetric keys are very simple, and are useful when you trust all the services that are verifying keys.

Asymmetric keys have a private key, and a public key. Services that are issuing tokens need the private key, and only the private key can be used to issue tokens. Services that are verifying tokens only need the public key, and the public key can't be used to issue tokens. This is useful for when you don't trust the services that are verifying tokens.

== JWT Key Configuration

Before the JWT feature can be used, JWT keys need to be set up for a service. Each service can have a list of keys associated with it. This allows JWTs from multiple different sources and for multiple different destinations that may require their own keys to be validated and signed. Kalix decides on a key to use first by issuer, then by key id. If a JWT has no issuer defined, then all keys are considered capable of signing or validating it. If a JWT has no key id defined, then the first key in the list that matches the issuer and algorithm being used is chosen.

Kalix supports the following algorithms:

|===
|Name |Description |Type

|HMD5 |HMAC with MD5 |Symmetric

|HS224 |HMAC with SHA224 |Symmetric

|HS256 |HMAC with SHA256 |Symmetric

|HS384 |HMAC with SHA384 |Symmetric

|HS512 |HMAC with SHA512 |Symmetric

|RS256 |RSA with SHA256 |Asymmetric

|RS384 |RSA with SHA384 |Asymmetric

|RS512 |RSA with SHA512 |Asymmetric

|ES256 |ECDSA with SHA256 |Asymmetric

|ES384 |ECDSA with SHA384 |Asymmetric

|ES512 |ECDSA with SHA512 |Asymmetric

|Ed25519 |Ed25519 |Asymmetric
|===

Which algorithm is suitable for you to use depends on your particular requirements, but we recommend `HS256` for symmetric keys, and `ES256` for asymmetric keys.

=== Listing keys

You can list all the keys in your service by running:

----
kalix services jwts list <my-service>
----

This command does not output the secrets themselves. To see the secrets, you can output as JSON:

----
kalix services jwts list <my-service> -o json
----

=== Generating a key for a service

If you don’t have a specific key that you want to use, you can let kalix generate one for you:

----
kalix services jwts generate <my-service> \
  --key-id <my-key-id> \
  --algorithm HS256 \
  --issuer <my-issuer> \
  --secret <my-secret-name>
----

This will do two things, it will:

* Create a new secret suitable for use with the selected algorithm named according to the `--secret` argument.
* Add a JWT key to the service that references that secret.

The `--issuer` is optional, but recommended. It will ensure that if a JWT specifies an issuer claim (`iss`), only that key will be used to verify that claim. This prevents spoofing of issuer claims. The `--key-id` is required, and should be unique to the service.

The `--secret` argument is optional, if not present, the name of the secret will be the argument passed to `--key-id`.

=== Adding a key for a service

If you've already created a suitable JWT secret, you can add it to a service. For example, perhaps you generated a secret for service A, and you want service B to reuse the same secret. This can be done using the `kalix service jwts add` command:

----
kalix services jwts add <my-service> \
  --key-id <my-key-id> \
  --algorithm HS256 \
  --issuer <my-issuer> \
  --secret <my-secret-name>
----

==== Managing secrets

To create secrets yourself, you can use the `kalix secrets` command. To create a symmetric secret for use with HMAC algorithms:

----
kalix secrets create symmetric <my-secret-name> \
  --secret-key-literal "<some-secret-text>"
----

The secret can also come from a file:

----
kalix secrets create symmetric <my-secret-name> \
  --secret-key /path/to/secret.key
----

To create an asymmetric secret:

----
kalix secrets create asymmetric <my-secret-name> \
  --private-key /path/to/private.key \
  --public-key /path/to/public.key
----

The public and private keys must be PEM encoded keys, either RSA, ECDSA or Ed25519. We recommend PKCS8 encoded private keys (that is, keys with a PEM header of `BEGIN PRIVATE KEY`) and PKIX encoded public keys (with a header of `BEGIN PUBLIC KEY`), but we also support PKCS1 (`BEGIN RSA PRIVATE/PUBLIC KEY`) and SEC.1 (`BEGIN EC PRIVATE KEY`). For some encodings, `kalix` may prompt to convert them to a format that the JWT support will work with.

The public and private keys are optional, however you must specify at least one of them. For example, if you have a service that only needs the key to validate JWTs issued by another service, you may configure a secret for it that just contains the public key so that it is unable to sign JWTs with that key.

If you only have the private key, you can also ask Kalix to extract the public key from the private key, rather than having to do it manually yourself and passing it using the `--public-key` flag:

----
kalix secrets create asymmetric <my-secret-name> \
  --private-key /path/to/private.key \
  --extract-public-key
----

Kalix’s JWT support is configured by placing annotations on methods in your endpoints.

== Authentication

Kalix can validate the signature of JWT tokens provided in an Authorization header to grant access to your endpoints. Typically, these tokens will be generated in response to an authentication request, e.g. by supplying refresh token, or perhaps a username and password. These tokens may be generated by a third party service such as Auth0. You can find more information about the generating tokens https://supertokens.com/blog/are-you-using-jwts-for-user-sessions-in-the-correct-way[here].

=== Bearer token validation

If you want to validate the bearer token of a request, you need to annotate your endpoint like:

[source, java, indent=0]
----
include::example$spring-doc-snippets/src/main/java/com/example/jwt/JWTAction.java[tag=bearer-token]
----
<1> Validating the Bearer is present in the Authorization header.


Only requests that have a bearer token that can be validated by one of the configured keys for the service will be allowed, all other requests will be rejected. The bearer token must be supplied with requests using the Authorization header, like:

----
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
----


If you want to assert that only tokens from a particular issuer are allowed, that be can be done using the `bearerTokenIssuer` option:

[source, java, indent=0]
----
include::example$spring-doc-snippets/src/main/java/com/example/jwt/JWTAction.java[tag=bearer-token-issuer]
----
<1> The token extracted from the bearer token must have this issuer.

It is recommended that this be used in combination with specifying an issuer in your JWT key configuration, otherwise any of the services whose keys you trust may spoof the issuer.

Kalix will place the claims from the validated token into the request metadata, so you can access it from your service. All claims are prefixed with `_kalix-jwt-claim-`, so for example, if you want to read the subject claim, you can read the metadata entry `_kalix-jwt-claim-sub`. String claims are passed unquoted. All other claim types, including arrays and objects, are passed using their JSON encoding


== Running locally with JWT support

When running locally using docker compose, by default, a dev key with id `dev` is configured for use. This key uses the JWT `none` signing algorithm, which means the JWT tokens produced do not contain a cryptographic signature, nor are they validated against a signature when validating. Therefore, when calling an endpoint with a bearer token, only its presence is validated

If you wish to set the issuer for this dev key, you can do that modifying the `docker-compose.yml` file in your project, setting the `JWT_DEV_SECRET_ISSUER` environment variable in the `kalix-proxy` service:

[source,yaml]
----
version: "3"
services:
  kalix-proxy:
    ...
    environment:
      JWT_DEV_SECRET_ISSUER: "my-issuer"
      ...
----